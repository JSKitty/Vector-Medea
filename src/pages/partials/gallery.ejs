<div id="media-container" class="g-2 p-1">
</div>
<div id="no-media" class="visually-hidden text-center py-5"><p>No more media files found <i class="fa-regular fa-face-frown-open"></i></p></div>
<div id="sentinel"></div>
<div class="d-flex justify-content-center">
    <div class="spinner-border text-secondary mt-5" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
</div>
<style>


#media-container {
    display: flex;
    justify-content: center;
    gap: 10px; /* Ajusta el espacio entre las columnas */
}

.media-column {
    display: flex;
    flex-direction: column;
    gap: 10px; /* Ajusta el espacio entre los elementos dentro de una columna */
}

.btn-container {
    opacity: 0;
    transform: translateY(20px);
    transition: all 0.3s ease-in-out;
}

.btn-container .btn{
    min-width: 30px;
}

.media-div:hover .btn-container {
    opacity: 1;
    transform: translateY(0);
}

.fade-in {
  opacity: 0;
  animation: fadeIn 2s forwards;
}

@keyframes fadeIn {
  to {
      opacity: 1;
  }
}

</style>
<script src="https://cdn.jsdelivr.net/npm/blurhash@1.1.4/dist/blurhash.min.js"></script>

<script src="/static/js/semaphore.js"></script>
<script>
storeAuthkey("<%= request.session.authkey %>")
document.addEventListener('DOMContentLoaded', (event) => {
    let page = 0;
    let isIntersecting = false;
    let lastClickedMedia = null;
    let mediaCount = 10;
    const columns = 5; // Número de columnas en el diseño "masonry"
    const columnElements = [];
    const columnHeights = Array(columns).fill(0); // Array to keep track of column heights

    const mediaContainer = document.getElementById('media-container');
    for (let i = 0; i < columns; i++) {
        const column = document.createElement('div');
        column.classList.add('media-column');
        column.style.flex = '1'; // Asegura que las columnas crezcan uniformemente
        column.id = `column-${i}`; // Assign an ID for debugging purposes
        mediaContainer.appendChild(column);
        columnElements.push(column);
    }

    const sentinel = document.getElementById('sentinel');

    const observer = new IntersectionObserver(async (entries, observer) => {
        entries.forEach(async entry => {
            if (entry.isIntersecting) {
                isIntersecting = true;
                while (isIntersecting) {
                    console.debug('Intersecting sentinel');
                    const response = await fetch(`/api/v2/media?page=${page}&count=${mediaCount}`, {
                        method: "GET",
                        headers: {
                            "authorization": "Bearer " + localStorage.getItem('authkey') || '',
                        },
                    });
                    page++;
                    const userData = await response.json();
                    response.headers.get("Authorization") ? await storeAuthkey(response.headers.get("Authorization")) : null;
                    if (userData.files && userData.files.length === 0) {
                        const spinner = document.querySelector('.spinner-border');
                        spinner.remove();
                        isIntersecting = false;
                        const noMediaElement = document.getElementById('no-media');
                        noMediaElement.classList.remove('visually-hidden');
                        break;
                    }
                    for (const file of userData.files) {
                        const url = file.tags.find(tag => tag[0] === 'url')[1];
                        const ext = url.split('.').pop();
                        const height = parseInt(file.tags.find(tag => tag[0] === 'dim')[1].trim().split('x')[1], 10) || 220;
                        console.log('url', url);
                        console.debug('height', height);
                        let mediaLink = document.createElement('a');
                        let mediaElement;
                        if (ext === 'webp' || ext === 'gif' || ext === 'jpg' || ext === 'jpeg') {
                            mediaElement = document.createElement('img');
                            mediaElement.src = '/static/resources/loading-image.webp';
                            mediaElement.classList.add("rounded-3", "w-100", "object-fit-contain");

                            let mediaLoader = new Image();
                            mediaLoader.src = `${url}`;

                            mediaLoader.onload = function() {
                                mediaElement.src = mediaLoader.src;
                            };

                        } else if (ext === 'mp4' || ext === 'mov') {
                            mediaElement = document.createElement('video');
                            mediaElement.classList.add("rounded-3", "w-100", "object-fit-contain");
                            mediaElement.setAttribute('muted', '');
                            mediaElement.setAttribute('playsinline', '');
                            mediaElement.setAttribute('autoplay', '');
                            mediaElement.setAttribute('loop', '');
                            mediaElement.setAttribute('poster', '/static/resources/loading-video.webp');

                            const handleVideoError = function(error) {
                                mediaElement.removeEventListener('error', handleVideoError);
                                mediaElement.poster = `${url}`;
                                mediaElement.src = "";
                                mediaElement.load();
                            };

                            mediaElement.addEventListener('error', handleVideoError);
                            mediaElement.src = `${url}`;
                            mediaElement.load();

                            // Autoplay video patch
                            mediaElement.muted = true;
                            const playPromise = mediaElement.play();
                            if (playPromise !== undefined) {
                                playPromise.then(() => {}).catch(error => {
                                    mediaElement.play();
                                });
                            }

                            // Pause video when it's not in the viewport
                            const videoObserver = new IntersectionObserver((entries) => {
                                entries.forEach(entry => {
                                    if (entry.isIntersecting) {
                                        setTimeout(() => {
                                            mediaElement.play();
                                        }, 100);
                                    } else {
                                        mediaElement.pause();
                                    }
                                });
                            });
                            videoObserver.observe(mediaElement);

                        } else if (ext === 'mp3') {
                            mediaElement = document.createElement('audio');
                            mediaElement.src = `${url}`;
                            mediaElement.classList.add("ps-5", "pe-5");
                            mediaElement.setAttribute('controls', '');

                            let hasBeenPlayed = false;
                            mediaElement.addEventListener('play', () => {
                                hasBeenPlayed = true;
                            });

                            // Pause audio when it's not in the viewport
                            const audioObserver = new IntersectionObserver((entries) => {
                                entries.forEach(entry => {
                                    if (!entry.isIntersecting) {
                                        setTimeout(() => {
                                            mediaElement.pause();
                                        }, 100);
                                    } else if (hasBeenPlayed) {
                                        setTimeout(() => {
                                            mediaElement.play();
                                        }, 100);
                                    }
                                });
                            });
                            audioObserver.observe(mediaElement);
                        }

                        if (mediaElement) {
                            const mediaDiv = document.createElement('div');
                            mediaDiv.classList.add("mb-0", "fade-in", "media-div");
                            mediaDiv.style.height = `${height}`;
                            mediaDiv.style.position = "relative";
                            if (ext === 'mp3') {
                                mediaDiv.style.height = "220px";
                                mediaDiv.style.background = "url('/static/resources/loading-music.webp') center center / cover no-repeat";
                                mediaDiv.classList.add("rounded-3", "d-flex", "flex-column", "align-items-center", "justify-content-end", "pb-2");
                            }
                            mediaDiv.appendChild(mediaLink);
                            mediaLink.appendChild(mediaElement);

                            mediaElement.addEventListener('click', (event) => {
                                event.preventDefault();
                                const buttonContainer = mediaDiv.querySelector('.btn-container');
                                if (lastClickedMedia && lastClickedMedia !== mediaElement) {
                                    const lastButtonContainer = lastClickedMedia.closest('.media-div').querySelector('.btn-container');
                                    if (lastButtonContainer) {
                                        lastButtonContainer.style.opacity = 0;
                                    }
                                }
                                if (buttonContainer) {
                                    buttonContainer.classList.style.opacity = 1;
                                }
                                lastClickedMedia = mediaElement;
                            });

                            // Buttons div
                            if (response.headers.get("Authorization")) {
                                const buttonContainer = document.createElement('div');
                                buttonContainer.classList.add('btn-container', 'position-absolute', 'bottom-0', 'start-0', 'd-flex', 'p-1');
                                buttonContainer.style.background = 'rgba(0, 0, 0, 0.5)';
                                buttonContainer.style.borderRadius = '5px';
                                buttonContainer.style.zIndex = '10';

                                const reorderButton = document.createElement('button');
                                reorderButton.classList.add('btn', 'btn-primary', 'btn-sm', 'me-1');
                                reorderButton.innerHTML = '<i class="fas fa-sort"></i>';
                                buttonContainer.appendChild(reorderButton);

                                const infoButton = document.createElement('button');
                                infoButton.classList.add('btn', 'btn-primary', 'btn-sm', 'me-1');
                                infoButton.innerHTML = '<i class="fas fa-info"></i>';
                                buttonContainer.appendChild(infoButton);

                                const viewButton = document.createElement('button');
                                viewButton.classList.add('btn', 'btn-primary', 'btn-sm', 'me-1');
                                viewButton.innerHTML = '<i class="fas fa-eye"></i>';
                                viewButton.addEventListener('click', (event) => {
                                    event.stopPropagation();
                                    window.open(`${url}`, '_blank');
                                });
                                buttonContainer.appendChild(viewButton);

                                const payButton = document.createElement('button');
                                payButton.classList.add('btn', 'btn-warning', 'btn-sm', 'me-1');
                                payButton.innerHTML = '<i class="fas fa-bolt"></i>';
                                buttonContainer.appendChild(payButton);

                                const deleteButton = document.createElement('button');
                                deleteButton.classList.add('btn', 'btn-danger', 'btn-sm', 'me-1');
                                deleteButton.innerHTML = '<i class="fas fa-trash"></i>';
                                buttonContainer.appendChild(deleteButton);

                                mediaDiv.appendChild(buttonContainer);
                            }

                            // Add the element to the shortest column
                            const shortestColumnIndex = columnHeights.indexOf(Math.min(...columnHeights));
                            const shortestColumn = columnElements[shortestColumnIndex];
                            shortestColumn.appendChild(mediaDiv);

                            // Update the height of the shortest column
                            columnHeights[shortestColumnIndex] += height;

                            mediaDiv.style.height = 'auto'; // Reset the height to allow the image to load
                        }
                    }

                    // Move the sentinel to the shortest column
                    const shortestColumnIndex = columnHeights.indexOf(Math.min(...columnHeights));
                    const shortestColumn = columnElements[shortestColumnIndex];
                    shortestColumn.appendChild(sentinel);
                    console.log('sentinel moved to column', shortestColumnIndex);


                    // Rescan the real height of the columns
                    console.log('Rescanning column heights');
                    console.log('old heights', columnHeights);
                    columnHeights.fill(0);
                    columnElements.forEach((column, index) => {
                        column.querySelectorAll('.media-div').forEach(mediaDiv => {
                            const height = mediaDiv.clientHeight;
                            columnHeights[index] += height;
                        });
                      
                    });

                    console.log('new heights', columnHeights);

                }
            } else {
                isIntersecting = false;
            }
        });
    }, {
        rootMargin: '500px'
    });
    observer.observe(sentinel);
});


</script>